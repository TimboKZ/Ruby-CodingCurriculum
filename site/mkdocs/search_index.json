{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nThis is a documentation on learning programming with Ruby created for Coding Curriculum project at University College London. This content is aimed at highschool students of age 15-18 but in theory in should be suitable for younger audience too.\n\n\nQuick word about the authors\n\n\nHello there, we are Ashley, Zac, Artem and Tim and we study Computer Science at a fine institution known as \nUniversity College London\n. Making this project was a part of our ENGS102P Design and Professional Skills module and we tried our best to come up with something interesting for you. We love coding (well, we do study Computer Science after all) and we want to share this passion with you. If you're still not sure whether you'd like to learn programming or not, read the section below and hopefully it will help you decide. We sincerely hope you will enjoy every single part of this tutorial!\n\n\nWhy bother learning to code?\n\n\nFirst of all, coding is fun! This is pretty much the reason why we all got into coding when we were younger and no matter how much you code it becomes more and more fun with each new thing you learn.\n\n\nOn a more serious note, there are many benefits to learning how to program, here's a small list of them that will hopefully convince you that it is worth your time:\n\n\n\n\nWriting good code is all about approaching the problem at hand from a very logical point of view. The more programming you will do the better you will become at finding solutions to various problems, whether they are related to logic, maths or algorithms.\n\n\nWith just the basic knowledge of some programming language you can save yourself time by automating different tasks in your daily routine, such as checking your mail, renaming photos according to the date they were taken or sorting documents on your computer.\n\n\nThe programs you use on your computer every day have also been written in some way. Having some programming knowledge will help you better understand how exactly they work or why you experience certain problems. With enough enthusiasm you can even attempt to fix existing issues using the knowledge you have acquired!\n\n\n\n\nThere is a huge amount of other advantages to knowing how to code which you can find out about by doing a quick Google search. If you liked what you've heard so far, move on to the next section where we will tell you about the programming language we decided to teach you.\n\n\nOur language of choice: Ruby\n\n\n\n\nRuby is an \nobject-oriented language\n developed in 1990s. The main reason why we chose this language over a numerous amount of other languages was that it is one of the easiest programming languages to learn. Compared to more well-known languages such as Java and C++, Ruby requires way less lines of codes to achieve the same result and although this is not necessarily better, it is certainly helpful for beginners who had very little or no prior experience with coding.\n\n\nAnother notable benefit of learning Ruby is that at the moment there is a high demand for Ruby developers out there, so if you'll ever decide to extend your knowledge of Ruby further from what we've told you, you'll even be able to find a well-paying job as a Ruby developer.\n\n\nHopefully, everything you've read above have convinced that programming is definitely something worth getting into and that learning Ruby is a good starting point. Feel free to click the \nNext\n button to see how you can get started.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "This is a documentation on learning programming with Ruby created for Coding Curriculum project at University College London. This content is aimed at highschool students of age 15-18 but in theory in should be suitable for younger audience too.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#quick-word-about-the-authors", 
            "text": "Hello there, we are Ashley, Zac, Artem and Tim and we study Computer Science at a fine institution known as  University College London . Making this project was a part of our ENGS102P Design and Professional Skills module and we tried our best to come up with something interesting for you. We love coding (well, we do study Computer Science after all) and we want to share this passion with you. If you're still not sure whether you'd like to learn programming or not, read the section below and hopefully it will help you decide. We sincerely hope you will enjoy every single part of this tutorial!", 
            "title": "Quick word about the authors"
        }, 
        {
            "location": "/#why-bother-learning-to-code", 
            "text": "First of all, coding is fun! This is pretty much the reason why we all got into coding when we were younger and no matter how much you code it becomes more and more fun with each new thing you learn.  On a more serious note, there are many benefits to learning how to program, here's a small list of them that will hopefully convince you that it is worth your time:   Writing good code is all about approaching the problem at hand from a very logical point of view. The more programming you will do the better you will become at finding solutions to various problems, whether they are related to logic, maths or algorithms.  With just the basic knowledge of some programming language you can save yourself time by automating different tasks in your daily routine, such as checking your mail, renaming photos according to the date they were taken or sorting documents on your computer.  The programs you use on your computer every day have also been written in some way. Having some programming knowledge will help you better understand how exactly they work or why you experience certain problems. With enough enthusiasm you can even attempt to fix existing issues using the knowledge you have acquired!   There is a huge amount of other advantages to knowing how to code which you can find out about by doing a quick Google search. If you liked what you've heard so far, move on to the next section where we will tell you about the programming language we decided to teach you.", 
            "title": "Why bother learning to code?"
        }, 
        {
            "location": "/#our-language-of-choice-ruby", 
            "text": "Ruby is an  object-oriented language  developed in 1990s. The main reason why we chose this language over a numerous amount of other languages was that it is one of the easiest programming languages to learn. Compared to more well-known languages such as Java and C++, Ruby requires way less lines of codes to achieve the same result and although this is not necessarily better, it is certainly helpful for beginners who had very little or no prior experience with coding.  Another notable benefit of learning Ruby is that at the moment there is a high demand for Ruby developers out there, so if you'll ever decide to extend your knowledge of Ruby further from what we've told you, you'll even be able to find a well-paying job as a Ruby developer.  Hopefully, everything you've read above have convinced that programming is definitely something worth getting into and that learning Ruby is a good starting point. Feel free to click the  Next  button to see how you can get started.", 
            "title": "Our language of choice: Ruby"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Installation\n\n\nTo be added in the future", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/#to-be-added-in-the-future", 
            "text": "", 
            "title": "To be added in the future"
        }, 
        {
            "location": "/getting-started/scripts/", 
            "text": "Running Ruby Scripts\n\n\nTo be added in the future", 
            "title": "Running scripts"
        }, 
        {
            "location": "/getting-started/scripts/#running-ruby-scripts", 
            "text": "", 
            "title": "Running Ruby Scripts"
        }, 
        {
            "location": "/getting-started/scripts/#to-be-added-in-the-future", 
            "text": "", 
            "title": "To be added in the future"
        }, 
        {
            "location": "/challenge-1/", 
            "text": "Outline\n\n\nYour first challenge involves the creation of a simple quiz game. Do not worry, we're not going to jump into the complicated stuff straight away - first, we will introduce basic concepts behind programming in Ruby and only then will we guide you through the process of creating a game.\n\n\nThis tutorial is split into 2 parts:\n\n\n\n\nFirst, you will learn the very basics and make a very simple quiz game using the knowledge you've acquired so far.\n\n\nIn the second part we will introduce you to some more advanced concepts and we will show you how you can improve the game you have created.\n\n\n\n\nPrerequisites:\n\n\n\n\nAlthough you don't need any prior programming experience to complete Challenge #1, having some would make the learning process easier\n\n\nInstalled and configured Ruby environment\n\n\nA topic to focus your quiz game on\n\n\nLots of enthusiasm!\n\n\n\n\nWhat you will learn in this tutorial:\n\n\n\n\nWorking with types and variables\n\n\nWorking with loops, if statements and understand how does the scope in Ruby work\n\n\nUnderstanding hashes and arrays\n\n\nGetting user input\n\n\nWorking with objects and their methods\n\n\n\n\nGood luck!", 
            "title": "Outline"
        }, 
        {
            "location": "/challenge-1/#outline", 
            "text": "Your first challenge involves the creation of a simple quiz game. Do not worry, we're not going to jump into the complicated stuff straight away - first, we will introduce basic concepts behind programming in Ruby and only then will we guide you through the process of creating a game.  This tutorial is split into 2 parts:   First, you will learn the very basics and make a very simple quiz game using the knowledge you've acquired so far.  In the second part we will introduce you to some more advanced concepts and we will show you how you can improve the game you have created.", 
            "title": "Outline"
        }, 
        {
            "location": "/challenge-1/#prerequisites", 
            "text": "Although you don't need any prior programming experience to complete Challenge #1, having some would make the learning process easier  Installed and configured Ruby environment  A topic to focus your quiz game on  Lots of enthusiasm!", 
            "title": "Prerequisites:"
        }, 
        {
            "location": "/challenge-1/#what-you-will-learn-in-this-tutorial", 
            "text": "Working with types and variables  Working with loops, if statements and understand how does the scope in Ruby work  Understanding hashes and arrays  Getting user input  Working with objects and their methods   Good luck!", 
            "title": "What you will learn in this tutorial:"
        }, 
        {
            "location": "/challenge-1/variables-types/", 
            "text": "Variables in Ruby\n\n\nIn Ruby you store all of your information, such as numbers and strings, in variables. There are several types of variables used in Ruby and this part of challenge #1 will introduce you to all of them.\n\n\nA quick example\n\n\nBelow you can find a simple example of usage of variables, don't try to think about too much yet - we'll explain how exactly it works later.\n\n\nfirst_variable = \"Some Value\"\ninteger_variable = 1\n\n\n\nThe code above simply means that the variable with the name \nfirst_variable\n now holds a value of \nSome Value\n, which is a string. \ninteger_variable\n on the other holds value of \n1\n, which, as the name implies, is an integer. As you can see any variable in Ruby can hold any value, regardless of its type - whether it is a decimal number, integer, string or even a collection of strings (don't worry about them for now, we'll talk about them in other tutorials).\n\n\n\n\nThe process of assigning a value to a variable is referred to as \ninitialising\n. For example, assigning a value of \n10\n to a variable named \nbox_size\n can be called initialising variable \nbox_size\n to \n10\n.\n\n\n\n\nI want to quickly introduce a simple function called \nputs\n. You will learn more about it in the next chapter about output, but for now all you need to know is that this function prints the value of the variable supplied to it. Consider this example:\n\n\n# Define some variable\nmy_variable = 1234\n\n# This function will output the value of my_variable\nputs my_variable\n# Outputs \"1234\"\n\n\n\nWe will use the \nputs\n function to see the values currently stored in our variables.\n\n\nNaming conventions\n\n\nIn the example above you might've noticed that each variable must have a name. In Ruby, there are specific coding conventions regarding the way you name strings, but do not worry, they are quite straight forward:\n\n\n\n\nFirst of all, the variable names are \ncase-sensitive\n. This means that \nVaRiAbLe\n and \nvariable\n are considered to be 2 different variables.\n\n\nSecondly, variable names must only contain alphanumeric characters or underscores (\n_\n). That is to say you can only use letters A to Z, digits 0 to 9 and the \n_\n symbol when naming a variable.\n\n\nA variable name cannot begin from a capital letter.\n\n\n\n\nFor now, following these points will suffice. At a later stage we will introduce you to a couple more concepts in variable naming and different variable types.\n\n\n\n\nNote\n: To make your variable names more descriptive try composing them from several words separated by underscores, i.e.:\n\n\n\n\n# Price of a single car in pounds\ncar_price_in_GBP = 400\n\n\n\nWhat are variables useful for?\n\n\n\n\nTo simplify the learning process for now let's only consider variables that store numbers for now.\n\n\n\n\nYou can do various manipulations with variables. For now, let's focus on the basic operations such as addition, subtraction, division and multiplication.\n\n\ninteger = 10\ndecimal_number = 2.5\nsum_variable = integer + decimal_number\ndifference = integer - decimal_number\nproduct_variable = integer * decimal_number\n\n\n\nAs you can see, the variables above hold the result of the operation corresponding to their names. For example, \ndifference\n now contains the value of \n7.5\n. An important feature of variables is that if you change one variable, all other variables that depend on it will change too: In this case, if we were to initialise \ninteger\n to \n8\n instead of \n10\n, the values of \nsum_variable\n, \ndifference\n and \nproduct_variable\n would change too.\n\n\nWhen initialising a variable to a number you can use parentheses just like you would do in algebra. Try to run the code below to confirm that the answer is correct:\n\n\ndecimal_number = (10 * 6.17) / 4.9 - 5\n\nputs decimal_number\n\n\n\nThere are many reasons why variables are extremely useful. Consider this simple example:\n\n\n\n\nYou are an owner of a shop that only sells 1 type of product and you're currently having a sale. For each customer, you know the amount of the product they want to buy, the price and the discount. The thing you want to calculate is the amount of money the customer will have to pay for their order.\n\n\n\n\nHere is how we you can implement it:\n\n\n# Price of a single product\nprice = 20\n\n# Discount in %\ndiscount = 10\n\n# Quantity to be bought\nquantity = 20\n\n# Now we begin our calculation\nprice_after_discount = price * (100 - discount) / 100\n\namount_to_pay = price_after_discount * quantity\n\n# And finally we print the answer\nputs amount_to_pay\n\n\n\nNow that the code is ready, you can just change the value of \nprice\n, \ndiscount\n or \nquantity\n to any other values and your program will calculate the rest for you. As you will find out in later tutorials, there are much better ways to do it but this solution will do for now.\n\n\nSome examples for you to try\n\n\nFirst of all, let's see if you understand how operations with numbers work in Ruby. Try to predict the output of this simple program:\n\n\nnumber_1 = 10\nnumber_2 = 24\nnumber_3 = number_2 * 2 - number_1 * 3\n\nresult = (number_3 + number_1) / 7\n\nputs result\n\n\n\nNow try to execute this code is see if you were correct.", 
            "title": "Working with variables"
        }, 
        {
            "location": "/challenge-1/variables-types/#variables-in-ruby", 
            "text": "In Ruby you store all of your information, such as numbers and strings, in variables. There are several types of variables used in Ruby and this part of challenge #1 will introduce you to all of them.", 
            "title": "Variables in Ruby"
        }, 
        {
            "location": "/challenge-1/variables-types/#a-quick-example", 
            "text": "Below you can find a simple example of usage of variables, don't try to think about too much yet - we'll explain how exactly it works later.  first_variable = \"Some Value\"\ninteger_variable = 1  The code above simply means that the variable with the name  first_variable  now holds a value of  Some Value , which is a string.  integer_variable  on the other holds value of  1 , which, as the name implies, is an integer. As you can see any variable in Ruby can hold any value, regardless of its type - whether it is a decimal number, integer, string or even a collection of strings (don't worry about them for now, we'll talk about them in other tutorials).   The process of assigning a value to a variable is referred to as  initialising . For example, assigning a value of  10  to a variable named  box_size  can be called initialising variable  box_size  to  10 .   I want to quickly introduce a simple function called  puts . You will learn more about it in the next chapter about output, but for now all you need to know is that this function prints the value of the variable supplied to it. Consider this example:  # Define some variable\nmy_variable = 1234\n\n# This function will output the value of my_variable\nputs my_variable\n# Outputs \"1234\"  We will use the  puts  function to see the values currently stored in our variables.", 
            "title": "A quick example"
        }, 
        {
            "location": "/challenge-1/variables-types/#naming-conventions", 
            "text": "In the example above you might've noticed that each variable must have a name. In Ruby, there are specific coding conventions regarding the way you name strings, but do not worry, they are quite straight forward:   First of all, the variable names are  case-sensitive . This means that  VaRiAbLe  and  variable  are considered to be 2 different variables.  Secondly, variable names must only contain alphanumeric characters or underscores ( _ ). That is to say you can only use letters A to Z, digits 0 to 9 and the  _  symbol when naming a variable.  A variable name cannot begin from a capital letter.   For now, following these points will suffice. At a later stage we will introduce you to a couple more concepts in variable naming and different variable types.   Note : To make your variable names more descriptive try composing them from several words separated by underscores, i.e.:   # Price of a single car in pounds\ncar_price_in_GBP = 400", 
            "title": "Naming conventions"
        }, 
        {
            "location": "/challenge-1/variables-types/#what-are-variables-useful-for", 
            "text": "To simplify the learning process for now let's only consider variables that store numbers for now.   You can do various manipulations with variables. For now, let's focus on the basic operations such as addition, subtraction, division and multiplication.  integer = 10\ndecimal_number = 2.5\nsum_variable = integer + decimal_number\ndifference = integer - decimal_number\nproduct_variable = integer * decimal_number  As you can see, the variables above hold the result of the operation corresponding to their names. For example,  difference  now contains the value of  7.5 . An important feature of variables is that if you change one variable, all other variables that depend on it will change too: In this case, if we were to initialise  integer  to  8  instead of  10 , the values of  sum_variable ,  difference  and  product_variable  would change too.  When initialising a variable to a number you can use parentheses just like you would do in algebra. Try to run the code below to confirm that the answer is correct:  decimal_number = (10 * 6.17) / 4.9 - 5\n\nputs decimal_number  There are many reasons why variables are extremely useful. Consider this simple example:   You are an owner of a shop that only sells 1 type of product and you're currently having a sale. For each customer, you know the amount of the product they want to buy, the price and the discount. The thing you want to calculate is the amount of money the customer will have to pay for their order.   Here is how we you can implement it:  # Price of a single product\nprice = 20\n\n# Discount in %\ndiscount = 10\n\n# Quantity to be bought\nquantity = 20\n\n# Now we begin our calculation\nprice_after_discount = price * (100 - discount) / 100\n\namount_to_pay = price_after_discount * quantity\n\n# And finally we print the answer\nputs amount_to_pay  Now that the code is ready, you can just change the value of  price ,  discount  or  quantity  to any other values and your program will calculate the rest for you. As you will find out in later tutorials, there are much better ways to do it but this solution will do for now.", 
            "title": "What are variables useful for?"
        }, 
        {
            "location": "/challenge-1/variables-types/#some-examples-for-you-to-try", 
            "text": "First of all, let's see if you understand how operations with numbers work in Ruby. Try to predict the output of this simple program:  number_1 = 10\nnumber_2 = 24\nnumber_3 = number_2 * 2 - number_1 * 3\n\nresult = (number_3 + number_1) / 7\n\nputs result  Now try to execute this code is see if you were correct.", 
            "title": "Some examples for you to try"
        }, 
        {
            "location": "/challenge-1/getting-input/", 
            "text": "Getting user input and producing output\n\n\nThere are many different ways to get input and produce output in Ruby, but in this part of our tutorial we will only look at several examples. To complete Challenge #1 we don't need to know them all, so we will try to focus on the parts that we require to solve the problem at hand.\n\n\nputs\n method", 
            "title": "Output and user input"
        }, 
        {
            "location": "/challenge-1/getting-input/#getting-user-input-and-producing-output", 
            "text": "There are many different ways to get input and produce output in Ruby, but in this part of our tutorial we will only look at several examples. To complete Challenge #1 we don't need to know them all, so we will try to focus on the parts that we require to solve the problem at hand.", 
            "title": "Getting user input and producing output"
        }, 
        {
            "location": "/challenge-1/getting-input/#puts-method", 
            "text": "", 
            "title": "puts method"
        }, 
        {
            "location": "/challenge-1/first-attempt/", 
            "text": "First proper program\n\n\nIn this part of the ruby tutorial you are going to learn on how to build a simple program, from the skills that you have gathered.\nThe first problem you are going to solve will be a quiz that will ask 3 questions about Japanese language and then output the player\ntheir final score.\n\n\nPutting everything together\n\n\nYou might have been wondering why learn ruby? what are its applications? how is anything I learned even useful?\n\n\nNow even though you covered only a minor proportion of ruby, real result can be seen already, and this is why we will practice building this program.\nOver the course of this time you have learned how to use functions, variables and how to use inputs and outputs.\nnow you are going to put your new learned skills in practice.\n\n\nWhat you need to do\n\n\nhere is the plan of the quiz:\n\n\nQuiz details\n\nChallenge No.1, Quiz questions\n  1.How do you say \"Hello\" in Japanese?\n  2.What is the literal translation of Tokyo?\n  3.Identify a choice that has both \"yes\" and \"no\" in Japanese?\n\n\n\n\n\nChallenge No.1, Quiz choices\n1.\n  1.Hallo\n  2.Konichiwa\n  3.Oyasumi\n  4.Itadakimasu\n  5.Ja Mate\n2.\n  1.Land of rising sun\n  2.Capital\n  3.Crazy place\n  4.East capital\n  5.Land of progress\n3.\n  1.hai, ii\n  2.ai, pie\n  3.yes, no\n  4.hai, iie\n  5.ha, ei\n\n\n\n\n\nChallenge No.1, Quiz answers\n  1.Konichiwa\n  2.East capital\n  3.hai, iie\n\n\n\nBuilding instructions\n\n\nSo, lets start building :) !!\n\n\nputs \"1. Hallo\"\nputs \"2. Konichiwa\"\nputs \"3. Oyasumi\"\nputs \"4. Itadakimasu\"\nputs \"5. Ja Mate\"\nputs\n\n\n\nnow look at the code above, you probably already know what it is supposed to do. What the code above does is outputs the first list of questions for the first\nquestion in the quiz which is then followed by a line break.\n\n\nSave this code in your editor and lets continue.\n(you can run the program to see the actual output. just double click on saved file)\n\n\n\n\nwhat we want to do next is declare a couple of global variables\n\n\n$questionNumber = 1\n$score = 0\n\n\n\nwrite this code prior to what you have already written, this will declare two global variables, one will keep track of the questionNumber the user is currently on\nand the other will keep the score.\n\n\n\n\nto ease the process of building a quiz we are going to use functions\nso lets write these two functions\n\n\ndef nextQuestion\n  print \"#{$questionNumber}. \"\n  $questionNumber += 1\nend\n\n\n\nthe function above will increment the global variable that keeps track of the question number as well as outputting the current number.\nThis means that we wouldnt have to write the question number our selves and more questions can be easily added at any time.\n\n\ndef processAnswer(choice, num)\n  puts\n  if choice==num\n $score += 1\n puts \"correct\"\n  else\nputs \"INCORRECT\"\n  end\n  puts\nend\n\n\n\nThis second function takes two parameters, one will be the choice that the user has selected as the answer and the other will be the actual answer.\n\n\nNow what this function will actually do is compare both values and if they match, the function will output \"correct\" and increment the users score. If the values dont match however, the output will be \"INCORRECT\" and the score wont be incremented.\n\n\n\n\nNow you have learned how to use input and output, so after outputing the first set of questions, insert this code\n\n\nchoice = gets.to_i\n\n\n\nnow what this will do is set a variable named choice, which will hold the users input, to what the input actually is (converted to an integer type using .to_i)\n\n\n\n\nlets put everything together and make the first quiz question.\n\n\n$questionNumber = 1\n$score = 0\n\ndef nextQuestion\n  print \"#{$questionNumber}. \"\n  $questionNumber += 1\nend\n\ndef processAnswer(choice, num)\n  puts\n  if choice==num\n $score += 1\n puts \"correct\"\n  else\nputs \"INCORRECT\"\n  end\n  puts\nend\n\nnextQuestion\nputs \"How do you say \\\"Hello\\\" in Japanese?\"\nputs\n\nputs \"1. Hallo\"\nputs \"2. Konichiwa\"\nputs \"3. Oyasumi\"\nputs \"4. Itadakimasu\"\nputs \"5. Ja Mate\"\nputs\n\nchoice = gets.to_i\n\nprocessAnswer(choice, 2)\n\n\n\nlook at the code above, as you can see we made use of functions like processAnswer(choice, 2) and nextQuestion, this code shouldnt be difficult to understand.\n\n\nyou might have noticed that Hello has \\\" written instead of just \", now this is because ruby will think that we want to end quotation marks if we just use \", so we say \\\" to tell ruby that its just a character to be outputted on screen.\n\n\nnow try the same with the next two questions.\n\n\nOnce you have done everything it is just the ending that is left.\n\n\nputs \"You got #{$score} in the quiz correct\"\n\n$end\n\n\n\nenter this code so that  user will get the output of his/her score. The $end will make sure ruby terminates.\n\n\nThe Final Code\n\n\n\n\n$questionNumber = 1\n$score = 0\n\ndef nextQuestion\n  print \"#{$questionNumber}. \"\n  $questionNumber += 1\nend\n\ndef processAnswer(choice, num)\n  puts\n  if choice==num\n $score += 1\n puts \"correct\"\n  else\nputs \"INCORRECT\"\n  end\n  puts\nend\n\nnextQuestion\nputs \"How do you say \\\"Hello\\\" in Japanese?\"\nputs\n\nputs \"1. Hallo\"\nputs \"2. Konichiwa\"\nputs \"3. Oyasumi\"\nputs \"4. Itadakimasu\"\nputs \"5. Ja Mate\"\nputs\n\nchoice = gets.to_i\n\nprocessAnswer(choice, 2)\nnextQuestion\nputs \"What is the literal translation of Tokyo?\"\nputs\n\nputs \"1. Land of rising sun\"\nputs \"2. Capital\"\nputs \"3. Crazy place\"\nputs \"4. East capital\"\nputs \"5. Land of progress\"\nputs\n\nchoice = gets.to_i\n\nprocessAnswer(choice, 4)\nnextQuestion\nputs \"Identify a choice that has both \\\"yes\\\" and \\\"no\\\" in japanese?\"\nputs\n\nputs \"1. hai, ii\"\nputs \"2. ai, pie\"\nputs \"3. yes, no\"\nputs \"4. hai, iie\"\nputs \"5. ha, ei\"\nputs\n\nchoice = gets.to_i\n\nprocessAnswer(choice,4)\nputs \"You got #{$score} in the quiz correct\"\n\n$end", 
            "title": "First attempt at the game"
        }, 
        {
            "location": "/challenge-1/first-attempt/#first-proper-program", 
            "text": "In this part of the ruby tutorial you are going to learn on how to build a simple program, from the skills that you have gathered.\nThe first problem you are going to solve will be a quiz that will ask 3 questions about Japanese language and then output the player\ntheir final score.", 
            "title": "First proper program"
        }, 
        {
            "location": "/challenge-1/first-attempt/#putting-everything-together", 
            "text": "You might have been wondering why learn ruby? what are its applications? how is anything I learned even useful?  Now even though you covered only a minor proportion of ruby, real result can be seen already, and this is why we will practice building this program.\nOver the course of this time you have learned how to use functions, variables and how to use inputs and outputs.\nnow you are going to put your new learned skills in practice.", 
            "title": "Putting everything together"
        }, 
        {
            "location": "/challenge-1/first-attempt/#what-you-need-to-do", 
            "text": "here is the plan of the quiz:  Quiz details\n\nChallenge No.1, Quiz questions\n  1.How do you say \"Hello\" in Japanese?\n  2.What is the literal translation of Tokyo?\n  3.Identify a choice that has both \"yes\" and \"no\" in Japanese?   Challenge No.1, Quiz choices\n1.\n  1.Hallo\n  2.Konichiwa\n  3.Oyasumi\n  4.Itadakimasu\n  5.Ja Mate\n2.\n  1.Land of rising sun\n  2.Capital\n  3.Crazy place\n  4.East capital\n  5.Land of progress\n3.\n  1.hai, ii\n  2.ai, pie\n  3.yes, no\n  4.hai, iie\n  5.ha, ei   Challenge No.1, Quiz answers\n  1.Konichiwa\n  2.East capital\n  3.hai, iie", 
            "title": "What you need to do"
        }, 
        {
            "location": "/challenge-1/first-attempt/#building-instructions", 
            "text": "So, lets start building :) !!  puts \"1. Hallo\"\nputs \"2. Konichiwa\"\nputs \"3. Oyasumi\"\nputs \"4. Itadakimasu\"\nputs \"5. Ja Mate\"\nputs  now look at the code above, you probably already know what it is supposed to do. What the code above does is outputs the first list of questions for the first\nquestion in the quiz which is then followed by a line break.  Save this code in your editor and lets continue.\n(you can run the program to see the actual output. just double click on saved file)   what we want to do next is declare a couple of global variables  $questionNumber = 1\n$score = 0  write this code prior to what you have already written, this will declare two global variables, one will keep track of the questionNumber the user is currently on\nand the other will keep the score.   to ease the process of building a quiz we are going to use functions\nso lets write these two functions  def nextQuestion\n  print \"#{$questionNumber}. \"\n  $questionNumber += 1\nend  the function above will increment the global variable that keeps track of the question number as well as outputting the current number.\nThis means that we wouldnt have to write the question number our selves and more questions can be easily added at any time.  def processAnswer(choice, num)\n  puts\n  if choice==num\n $score += 1\n puts \"correct\"\n  else\nputs \"INCORRECT\"\n  end\n  puts\nend  This second function takes two parameters, one will be the choice that the user has selected as the answer and the other will be the actual answer.  Now what this function will actually do is compare both values and if they match, the function will output \"correct\" and increment the users score. If the values dont match however, the output will be \"INCORRECT\" and the score wont be incremented.   Now you have learned how to use input and output, so after outputing the first set of questions, insert this code  choice = gets.to_i  now what this will do is set a variable named choice, which will hold the users input, to what the input actually is (converted to an integer type using .to_i)   lets put everything together and make the first quiz question.  $questionNumber = 1\n$score = 0\n\ndef nextQuestion\n  print \"#{$questionNumber}. \"\n  $questionNumber += 1\nend\n\ndef processAnswer(choice, num)\n  puts\n  if choice==num\n $score += 1\n puts \"correct\"\n  else\nputs \"INCORRECT\"\n  end\n  puts\nend\n\nnextQuestion\nputs \"How do you say \\\"Hello\\\" in Japanese?\"\nputs\n\nputs \"1. Hallo\"\nputs \"2. Konichiwa\"\nputs \"3. Oyasumi\"\nputs \"4. Itadakimasu\"\nputs \"5. Ja Mate\"\nputs\n\nchoice = gets.to_i\n\nprocessAnswer(choice, 2)  look at the code above, as you can see we made use of functions like processAnswer(choice, 2) and nextQuestion, this code shouldnt be difficult to understand.  you might have noticed that Hello has \\\" written instead of just \", now this is because ruby will think that we want to end quotation marks if we just use \", so we say \\\" to tell ruby that its just a character to be outputted on screen.", 
            "title": "Building instructions"
        }, 
        {
            "location": "/challenge-1/first-attempt/#now-try-the-same-with-the-next-two-questions", 
            "text": "Once you have done everything it is just the ending that is left.  puts \"You got #{$score} in the quiz correct\"\n\n$end  enter this code so that  user will get the output of his/her score. The $end will make sure ruby terminates.", 
            "title": "now try the same with the next two questions."
        }, 
        {
            "location": "/challenge-1/first-attempt/#the-final-code", 
            "text": "$questionNumber = 1\n$score = 0\n\ndef nextQuestion\n  print \"#{$questionNumber}. \"\n  $questionNumber += 1\nend\n\ndef processAnswer(choice, num)\n  puts\n  if choice==num\n $score += 1\n puts \"correct\"\n  else\nputs \"INCORRECT\"\n  end\n  puts\nend\n\nnextQuestion\nputs \"How do you say \\\"Hello\\\" in Japanese?\"\nputs\n\nputs \"1. Hallo\"\nputs \"2. Konichiwa\"\nputs \"3. Oyasumi\"\nputs \"4. Itadakimasu\"\nputs \"5. Ja Mate\"\nputs\n\nchoice = gets.to_i\n\nprocessAnswer(choice, 2)\nnextQuestion\nputs \"What is the literal translation of Tokyo?\"\nputs\n\nputs \"1. Land of rising sun\"\nputs \"2. Capital\"\nputs \"3. Crazy place\"\nputs \"4. East capital\"\nputs \"5. Land of progress\"\nputs\n\nchoice = gets.to_i\n\nprocessAnswer(choice, 4)\nnextQuestion\nputs \"Identify a choice that has both \\\"yes\\\" and \\\"no\\\" in japanese?\"\nputs\n\nputs \"1. hai, ii\"\nputs \"2. ai, pie\"\nputs \"3. yes, no\"\nputs \"4. hai, iie\"\nputs \"5. ha, ei\"\nputs\n\nchoice = gets.to_i\n\nprocessAnswer(choice,4)\nputs \"You got #{$score} in the quiz correct\"\n\n$end", 
            "title": "The Final Code"
        }, 
        {
            "location": "/challenge-1/loops/", 
            "text": "What is a loop?\n\n\nLoops can be used when you want to repeatedly do things.\nFor example, I would like to have 5 lines of \n\"Ruby is awesome!\"\n, instead of typing 5 times we can use a loop to help us achieve this. The most basic loop of all is a \nwhile\n loop Let's create a file and name it, here we do \nWhile.rb\n\n\nwhile\n\n\nwhile conditional (do)\n\n    code\n\nend\n\n--------or-------\n\nbegin\n\n    code\n\nend while conditional\n\n\n\nLet's look at a specific example:\n\n\ncounter = 0\n\nwhile counter \n 5\n\n    puts \"Ruby is awesome!\"\n\n    counter++\n\nend\n\n\n\nAlso you can write:\n\n\ncounter = 0\n\nbegin\n\n    puts \"Ruby is awesome!\"\n\n    counter++\n\nend while counter \n 5\n\n\n\nRun the program, on the terminal you will see:\n\n\nRuby is awesome!\nRuby is awesome!\nRuby is awesome!\nRuby is awesome!\nRuby is awesome!\n\n\n\nIn this case\n\n\n\n\n\n\ncounter \n 5\n is the condition\n\n\n\n\n\n\nputs \"Ruby is awesome!\"\n is the loop body.\n\n\n\n\n\n\nThe loop body will continuously repeating if the condition is \ntrue\n, stop until the condition is \nfalse\n. \n\n\nAt the beginning \ncounter = 0\n, 0 is less than 5 so the condition is true then we will get into the loop body to process the \nputs\n method, after we finish we do \ncounter++\n, which means counter plus 1, so now \ncounter = 1\n, it is still true, we go back to the start of the loop, do the puts method second time, keep doing this until counter = 5, when the condition is false, okay we jump out of the while loop and goes to \n\"end\"\n, the program is complete when it reaches \n\"end\"\n.\n\n\nThere are many loops\n\n\nWhile\n loop is the most basic of all loops but it is rather \"inconvenient\" to use for everything. Therefore, Ruby comes equipped with a variety of ways to declare loops that will help making your code more straight forward.\n\n\nuntil\n\n\nThe \nuntil\n loop is a alternative way which does exactly the same thing as \nwhile\n does. An \nuntil\n loop will repeat until the condition is \ntrue\n, i.e stops when the condition is \ntrue\n.\n\n\nuntil conditional (do)\n\n    code\n\nend\n\n--------or--------\n\nbegin\n\n    code\n\nend until conditional\n\n\n\nA more specific example of \nuntil\n method:\n\n\ncounter = 0\n\n    until counter \n 5\n\n    puts counter\n\n    counter++\n\nend\n\n\n\nSame as before you can put \nuntil\n at the end:\n\n\ncounter = 0\n\nbegin\n\n    puts counter\n\n    counter++\n\nend until counter \n 5\n\n\n\nThe output on the terminal is:\n\n\n0\n1\n2\n3\n4\n5\n\n\n\n\n\nfor\n\n\nThe \nfor\n loop is another way of doing loops, it has the structure of:\n\n\nfor variable (,variable...) in expression (do)\n\n    code\n\nend\n\n\n\nLet's see an example:\n\n\nfor x in 0..3\n\n    puts \"X is #{x}\"\n\nend\n\n\n\nOn the terminal:\n\n\nX is 0\nX is 1\nX is 2\nX is 3\n\n\n\n\n\nEach\n\n\nIn ruby, there is another method does exactly the same thing as \nfor..in\n does, it's structure is like this:\n\n\n(expression).each (do) |variable(,variable...)|\n\n    code\n\nend\n\n\n\nLet's do the same example:\n\n\n(0..5).each do |x|\n\n    puts \"X is #{x}\"\n\nend\n\n\n\nOn the terminal:\n\n\nX is 0\nX is 1\nX is 2\nX is 3\n\n\n\nbreak\n\n\nBreak will stop the loops.\n\n\nfor example:\n\n\nfor x in 0..3\n\n    if x \n 2 then\n\n        break\n\n    end\n\n    puts \"X is #{x}\"\n\nend\n\n\n\nOn the terminal:\n\n\nX is 0\nX is 1\nX is 2", 
            "title": "Loops"
        }, 
        {
            "location": "/challenge-1/loops/#what-is-a-loop", 
            "text": "Loops can be used when you want to repeatedly do things.\nFor example, I would like to have 5 lines of  \"Ruby is awesome!\" , instead of typing 5 times we can use a loop to help us achieve this. The most basic loop of all is a  while  loop Let's create a file and name it, here we do  While.rb", 
            "title": "What is a loop?"
        }, 
        {
            "location": "/challenge-1/loops/#while", 
            "text": "while conditional (do)\n\n    code\n\nend\n\n--------or-------\n\nbegin\n\n    code\n\nend while conditional  Let's look at a specific example:  counter = 0\n\nwhile counter   5\n\n    puts \"Ruby is awesome!\"\n\n    counter++\n\nend  Also you can write:  counter = 0\n\nbegin\n\n    puts \"Ruby is awesome!\"\n\n    counter++\n\nend while counter   5  Run the program, on the terminal you will see:  Ruby is awesome!\nRuby is awesome!\nRuby is awesome!\nRuby is awesome!\nRuby is awesome!  In this case    counter   5  is the condition    puts \"Ruby is awesome!\"  is the loop body.    The loop body will continuously repeating if the condition is  true , stop until the condition is  false .   At the beginning  counter = 0 , 0 is less than 5 so the condition is true then we will get into the loop body to process the  puts  method, after we finish we do  counter++ , which means counter plus 1, so now  counter = 1 , it is still true, we go back to the start of the loop, do the puts method second time, keep doing this until counter = 5, when the condition is false, okay we jump out of the while loop and goes to  \"end\" , the program is complete when it reaches  \"end\" .", 
            "title": "while"
        }, 
        {
            "location": "/challenge-1/loops/#there-are-many-loops", 
            "text": "While  loop is the most basic of all loops but it is rather \"inconvenient\" to use for everything. Therefore, Ruby comes equipped with a variety of ways to declare loops that will help making your code more straight forward.", 
            "title": "There are many loops"
        }, 
        {
            "location": "/challenge-1/loops/#until", 
            "text": "The  until  loop is a alternative way which does exactly the same thing as  while  does. An  until  loop will repeat until the condition is  true , i.e stops when the condition is  true .  until conditional (do)\n\n    code\n\nend\n\n--------or--------\n\nbegin\n\n    code\n\nend until conditional  A more specific example of  until  method:  counter = 0\n\n    until counter   5\n\n    puts counter\n\n    counter++\n\nend  Same as before you can put  until  at the end:  counter = 0\n\nbegin\n\n    puts counter\n\n    counter++\n\nend until counter   5  The output on the terminal is:  0\n1\n2\n3\n4\n5", 
            "title": "until"
        }, 
        {
            "location": "/challenge-1/loops/#for", 
            "text": "The  for  loop is another way of doing loops, it has the structure of:  for variable (,variable...) in expression (do)\n\n    code\n\nend  Let's see an example:  for x in 0..3\n\n    puts \"X is #{x}\"\n\nend  On the terminal:  X is 0\nX is 1\nX is 2\nX is 3   Each  In ruby, there is another method does exactly the same thing as  for..in  does, it's structure is like this:  (expression).each (do) |variable(,variable...)|\n\n    code\n\nend  Let's do the same example:  (0..5).each do |x|\n\n    puts \"X is #{x}\"\n\nend  On the terminal:  X is 0\nX is 1\nX is 2\nX is 3", 
            "title": "for"
        }, 
        {
            "location": "/challenge-1/loops/#break", 
            "text": "Break will stop the loops.  for example:  for x in 0..3\n\n    if x   2 then\n\n        break\n\n    end\n\n    puts \"X is #{x}\"\n\nend  On the terminal:  X is 0\nX is 1\nX is 2", 
            "title": "break"
        }, 
        {
            "location": "/challenge-1/arrays/", 
            "text": "What is an array?\n\n\nArray is a list of things used to store \nInteger, String, Fixnum, Hash, Symbol or even another Array\n.\n\n\nCreate Arrays\n\n\nUsing \"\nnew\n\" method.\n\n\n\n\nname = Array.new\n\n\n\n\n\nOkay, now you created an Array called \nname\n, it is not initialized nor been set size. \n\n\nSet array size\n\n\nYou can set array size by doing:\n\n\n\n\nname = Array.new(20)\n\n\n\n\n\nThis is a array contains 20 elements, each element is associated with an index pointing to it.\nYou can get the size/length of an array by doing:\n\n\n\n\nnames = Array.new(20)\n\nputs names.size\n\nputs names.length\n\n\n\n\n\nThe output is:\n\n\n\n\n20\n20\n\n\n\n\n\nAssignment\n\n\nAssigning \nrepeating\n things in when you created an array:\n\n\n\n\nnames = Array.new(3,\"home\")\n\nputs \"#{names}\"\n\n\n\n\n\nHere \n3\n is the number of times you want the string after to repeat.\n\n\nThe output is:\n\n\n\n\n[\"home\", \"home\", \"home\"]\n\n\n\n\n\nOr you can assign things using calculation:\n\n\n\n\nn = Array.new(10) { |x| x = x * 3}\n\nputs \"#{n}\"\n\n\n\n\n\nThe output is:\n\n\n\n\n[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]\n\n\n\n\n\nUsing \"[ ]\" to create array and put assignments.\n\n\n\n\nn = Array.[](1, 2, 3, 4)\n\n\n\n\n\nAlternatively:\n\n\n\n\nn = Array[1, 2, 3, 4]\n\n\n\n\n\nThe following is a method using a range as its parameter and it takes one parameter each time to create an array:\n\n\n\n\nn = Array(1..4)\n\nputs #{n}\n\n\n\n\n\nNotice that the \n\"a..b\"\n means \nfrom a to b\n.\n\n\nThe output is:\n\n\n\n\n[1, 2, 3, 4]\n\n\n\n\n\nAccessing array\n\n\nTo access a particular element of an array, you type:\n\n\nn = Array[1, 2, 3, 4]\nn[2]\n# alternatively\nn.at(2)\n\n\n\nArray is kind of an oddball in programming. You would expect the last 2 lines of code to give you the second element in the array which is 2. \nWRONG!!!\n It will return the third value in the array \nn\n which is 3.\nArray index it's elements starting from 0, this is not due to Ruby being special but a standard created by the first computer scientists a long time ago. Therefore,\n\n\nn[0]\n\n\n\nwill give you 1.", 
            "title": "Arrays"
        }, 
        {
            "location": "/challenge-1/arrays/#what-is-an-array", 
            "text": "Array is a list of things used to store  Integer, String, Fixnum, Hash, Symbol or even another Array .", 
            "title": "What is an array?"
        }, 
        {
            "location": "/challenge-1/arrays/#create-arrays", 
            "text": "", 
            "title": "Create Arrays"
        }, 
        {
            "location": "/challenge-1/arrays/#using-new-method", 
            "text": "name = Array.new   Okay, now you created an Array called  name , it is not initialized nor been set size.", 
            "title": "Using \"new\" method."
        }, 
        {
            "location": "/challenge-1/arrays/#set-array-size", 
            "text": "You can set array size by doing:   name = Array.new(20)   This is a array contains 20 elements, each element is associated with an index pointing to it.\nYou can get the size/length of an array by doing:   names = Array.new(20)\n\nputs names.size\n\nputs names.length   The output is:   20\n20", 
            "title": "Set array size"
        }, 
        {
            "location": "/challenge-1/arrays/#assignment", 
            "text": "Assigning  repeating  things in when you created an array:   names = Array.new(3,\"home\")\n\nputs \"#{names}\"   Here  3  is the number of times you want the string after to repeat.  The output is:   [\"home\", \"home\", \"home\"]   Or you can assign things using calculation:   n = Array.new(10) { |x| x = x * 3}\n\nputs \"#{n}\"   The output is:   [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]", 
            "title": "Assignment"
        }, 
        {
            "location": "/challenge-1/arrays/#using-to-create-array-and-put-assignments", 
            "text": "n = Array.[](1, 2, 3, 4)   Alternatively:   n = Array[1, 2, 3, 4]   The following is a method using a range as its parameter and it takes one parameter each time to create an array:   n = Array(1..4)\n\nputs #{n}   Notice that the  \"a..b\"  means  from a to b .  The output is:   [1, 2, 3, 4]", 
            "title": "Using \"[ ]\" to create array and put assignments."
        }, 
        {
            "location": "/challenge-1/arrays/#accessing-array", 
            "text": "To access a particular element of an array, you type:  n = Array[1, 2, 3, 4]\nn[2]\n# alternatively\nn.at(2)  Array is kind of an oddball in programming. You would expect the last 2 lines of code to give you the second element in the array which is 2.  WRONG!!!  It will return the third value in the array  n  which is 3.\nArray index it's elements starting from 0, this is not due to Ruby being special but a standard created by the first computer scientists a long time ago. Therefore,  n[0]  will give you 1.", 
            "title": "Accessing array"
        }, 
        {
            "location": "/challenge-1/hashes/", 
            "text": "Hashes\n\n\nHashes in Ruby are very similar to arrays you've learned about in the previous chapter. The main difference is quite subtle but makes a huge difference - while in arrays you use integers to access various elements, in hashes you can use an arbitrary object for the same purpose.\n\n\nWhy not just use arrays?\n\n\nConsider this problem: You need to make some data structure which will hold the population of various cities in Japan. Since arrays only support integer indices, you will have to assign an integer to each city:\n\n\n\n\n0\n - Kyoto\n\n\n1\n - Osaka\n\n\n2\n - Tokyo\n\n\n\n\nNow we can create the array itself and access the population of different cities:\n\n\npopulation_in_millions = Array[1.474473, 2.666371, 8.949447]\n\n\n\nAnd now we can use this array as follows:\n\n\n# Outputs the population of Kyoto\nputs populationArray[0]\n\n# Outputs the population of Osaka\nputs populationArray[0]\n\n\n\nThe major downside to using this method is that you have to assign each city to an integer, and whoever will be using your array in the future has to know what exactly each integer represents. Here is where hashes come into play - since you can use any object as the hash index, you can simply use strings instead of integers:\n\n\npopulation_in_millions = Hash[\"Kyoto\" =\n 1.474473, \"Osaka\" =\n 2.666371, \"\" =\n 8.949447]\n\n# Outputs the population of Osaka\nputs population_in_millions[\"Osaka\"]\n\n\n\nCreating hashes\n\n\nThe easiest way to create hashes is to create an empty hash:\n\n\nmy_hash = Hash.new\n\n\n\nNow that we have created a new hash, we can add and read information from it:\n\n\nmy_hash[\"colour\"] = \"red\"\nputs my_hash[\"colour\"]", 
            "title": "Hashes"
        }, 
        {
            "location": "/challenge-1/hashes/#hashes", 
            "text": "Hashes in Ruby are very similar to arrays you've learned about in the previous chapter. The main difference is quite subtle but makes a huge difference - while in arrays you use integers to access various elements, in hashes you can use an arbitrary object for the same purpose.", 
            "title": "Hashes"
        }, 
        {
            "location": "/challenge-1/hashes/#why-not-just-use-arrays", 
            "text": "Consider this problem: You need to make some data structure which will hold the population of various cities in Japan. Since arrays only support integer indices, you will have to assign an integer to each city:   0  - Kyoto  1  - Osaka  2  - Tokyo   Now we can create the array itself and access the population of different cities:  population_in_millions = Array[1.474473, 2.666371, 8.949447]  And now we can use this array as follows:  # Outputs the population of Kyoto\nputs populationArray[0]\n\n# Outputs the population of Osaka\nputs populationArray[0]  The major downside to using this method is that you have to assign each city to an integer, and whoever will be using your array in the future has to know what exactly each integer represents. Here is where hashes come into play - since you can use any object as the hash index, you can simply use strings instead of integers:  population_in_millions = Hash[\"Kyoto\" =  1.474473, \"Osaka\" =  2.666371, \"\" =  8.949447]\n\n# Outputs the population of Osaka\nputs population_in_millions[\"Osaka\"]", 
            "title": "Why not just use arrays?"
        }, 
        {
            "location": "/challenge-1/hashes/#creating-hashes", 
            "text": "The easiest way to create hashes is to create an empty hash:  my_hash = Hash.new  Now that we have created a new hash, we can add and read information from it:  my_hash[\"colour\"] = \"red\"\nputs my_hash[\"colour\"]", 
            "title": "Creating hashes"
        }, 
        {
            "location": "/challenge-1/scopes/", 
            "text": "Scopes in Ruby\n\n\nWill be added in the future . . .", 
            "title": "Scopes"
        }, 
        {
            "location": "/challenge-1/scopes/#scopes-in-ruby", 
            "text": "", 
            "title": "Scopes in Ruby"
        }, 
        {
            "location": "/challenge-1/scopes/#will-be-added-in-the-future", 
            "text": "", 
            "title": "Will be added in the future . . ."
        }, 
        {
            "location": "/challenge-1/built-in-methods/", 
            "text": "Built-in methods\n\n\nThe Core API\n\n\nIn order to make thing easier for us, Ruby comes equipped with a vast amount of built-in functions (or methods). As you may have noticed when you were learning about \nArrays\n, there are things you can do such as append another element to the end of the array or get an element out of the array. For example:\n\n\nan_array = [1,2,3,4,5]\nputs an_array\n\n\n\nthis will produce\n\n\n1\n2\n3\n4\n5\n\n\n\nNow add this line after it\n\n\nan_array.push(6)\nputs an_array # display the new array\n\n\n\nWe get\n\n\n1\n2\n3\n4\n5\n6\n\n\n\nYou can also reverse with \nan_array.reverse\n and many more.\nThese are built in methods of the \nCore API\n (let's understand API as a collection of libraries), which doesn't require you to import anything extra to use it, every class such as String, Hash, etc...(more on this later) has it's own built in functions.\n\n\nThe Standard Library\n\n\nSometimes you will encounter situations where there's no function in the Core library for you to use, that is when you have to resort to using the \nStandard Library\n. In order to use it, you need to include at the start of your Ruby program the line\n\n\nrequire \"standard_library_name\"\n\n\n\nstandard_library_name\n can be any library that you require to complete the task.\nFor example: \nYou are asked to calculate the square root of a complex number, there are 2 ways to go about doing it:\n\n\n\n\n\n\nYou go and create a method that will take in a number (i.e. -1) or a complex number and return the square root of it. \nHighly NOT recommended.\n\n\nYou use CMath library like so:\n\n\n\n\n\n\nrequire \"cmath\"\n\nputs CMath.sqrt(-1) # =\n 0+1.0i\n\n\n\n\n\n\"How do I know whether I should use the Core or Standard Library?\" You might ask. The answer is rather unexciting, you need to read the \nRuby Documentation\n. Thankfully, libraries and functions are named in a straight forward manner such as date and time related functions are all in a library called \nDateTime\n.\n\n\nThis is actually how programmers work, most of their time is spent reading the documentation of the language they are using to look for that required function.", 
            "title": "Built-in methods"
        }, 
        {
            "location": "/challenge-1/built-in-methods/#built-in-methods", 
            "text": "", 
            "title": "Built-in methods"
        }, 
        {
            "location": "/challenge-1/built-in-methods/#the-core-api", 
            "text": "In order to make thing easier for us, Ruby comes equipped with a vast amount of built-in functions (or methods). As you may have noticed when you were learning about  Arrays , there are things you can do such as append another element to the end of the array or get an element out of the array. For example:  an_array = [1,2,3,4,5]\nputs an_array  this will produce  1\n2\n3\n4\n5  Now add this line after it  an_array.push(6)\nputs an_array # display the new array  We get  1\n2\n3\n4\n5\n6  You can also reverse with  an_array.reverse  and many more.\nThese are built in methods of the  Core API  (let's understand API as a collection of libraries), which doesn't require you to import anything extra to use it, every class such as String, Hash, etc...(more on this later) has it's own built in functions.", 
            "title": "The Core API"
        }, 
        {
            "location": "/challenge-1/built-in-methods/#the-standard-library", 
            "text": "Sometimes you will encounter situations where there's no function in the Core library for you to use, that is when you have to resort to using the  Standard Library . In order to use it, you need to include at the start of your Ruby program the line  require \"standard_library_name\"  standard_library_name  can be any library that you require to complete the task.\nFor example: \nYou are asked to calculate the square root of a complex number, there are 2 ways to go about doing it:    You go and create a method that will take in a number (i.e. -1) or a complex number and return the square root of it.  Highly NOT recommended.  You use CMath library like so:    require \"cmath\"\n\nputs CMath.sqrt(-1) # =  0+1.0i   \"How do I know whether I should use the Core or Standard Library?\" You might ask. The answer is rather unexciting, you need to read the  Ruby Documentation . Thankfully, libraries and functions are named in a straight forward manner such as date and time related functions are all in a library called  DateTime .  This is actually how programmers work, most of their time is spent reading the documentation of the language they are using to look for that required function.", 
            "title": "The Standard Library"
        }, 
        {
            "location": "/challenge-1/creating-skeleton/", 
            "text": "", 
            "title": "Creating a skeleton for the game"
        }, 
        {
            "location": "/challenge-1/completing-challenge/", 
            "text": "", 
            "title": "Completing challenge #1"
        }, 
        {
            "location": "/challenge-2/", 
            "text": "Outline\n\n\nGreat job for completing your first game using Ruby! It's time to take it to the next level. It's time to dive deeper into the world of \nObject Oriented Programming\n also known as \nOOP\n and learn more about Ruby.\n\nIn this chapter, we will explore the 3 fundamental concepts that are Encapsulation, Inheritance and Polymorphism. Afterwards, we're going to get started on our second challenge which is to make a card game.\n\n\nPrerequisites:\n\n\n\n\nYou should be familiar with the concepts taught in chapter 1\n\n\nFinished creating and beat your quiz game!!!\n\n\nA lot more enthusiasm!!!\n\n\n\n\nWhat you will learn in this tutorial:\n\n\n\n\nProgram in the modern way - OOP.\n\n\nWorking with classes and objects\n\n\nModelling your program\n\n\nLearn about playing cards", 
            "title": "Outline"
        }, 
        {
            "location": "/challenge-2/#outline", 
            "text": "Great job for completing your first game using Ruby! It's time to take it to the next level. It's time to dive deeper into the world of  Object Oriented Programming  also known as  OOP  and learn more about Ruby. \nIn this chapter, we will explore the 3 fundamental concepts that are Encapsulation, Inheritance and Polymorphism. Afterwards, we're going to get started on our second challenge which is to make a card game.", 
            "title": "Outline"
        }, 
        {
            "location": "/challenge-2/#prerequisites", 
            "text": "You should be familiar with the concepts taught in chapter 1  Finished creating and beat your quiz game!!!  A lot more enthusiasm!!!", 
            "title": "Prerequisites:"
        }, 
        {
            "location": "/challenge-2/#what-you-will-learn-in-this-tutorial", 
            "text": "Program in the modern way - OOP.  Working with classes and objects  Modelling your program  Learn about playing cards", 
            "title": "What you will learn in this tutorial:"
        }, 
        {
            "location": "/challenge-2/OOP/", 
            "text": "Object Oriented Programming\n\n\nRuby\n is a pure Object Oriented Programming Language (OOP). You must remember that everything in Ruby (e.g. an integer, a decimal number or a string) is an object of a particular class.\n\n\nClasses and Objects\n\n\nIf programming is building a house, then a \nclass\n would be the blueprint and the \nobject\n would be the house or an \ninstance\n of a class.\n\n\nClass\n\n\nA class specifies the variables(what it's object has) and methods(what it's object does). To create a class, you need type:\n\n\nclass class_name\n\n    include anything related to the class here\n\nend\n\n\n\nFor example a pet dog class would have:\n\n\nclass Dog\n\n      @@number_of_legs = 4\n\n      # Basic initializer\n      def initialize(name, species, age)\n        # Assign the argument to the \"name\" instance variable for the instance\n        @name = name\n        # If no age given, we will fall back to the default in the arguments list.\n        @age = age\n\n        @species = species;\n      end\n\n      # Basic setter method\n      def name=(name)\n        @name = name\n      end\n\n      # Basic getter method\n      def name\n        @name\n      end\n\n      def species\n        @species\n      end\n\n      def age\n        @age\n      end\n\n      def legs\n        @@number_of_legs\n      end\n\n      def bark\n        puts \"bark,bark,bark\"\n      end\nend\n\n\n\nAs you can see, any variable with two '@' before it \n@@number_of_legs\n is a class variable. It is shared by all instances(objects) of this class. A dog should always have 4 legs, a name, age, species and the ability to bark which we will display \"bark\" 3 times.\nIn OOP it is good practice to always have constructor, getter and setter methods in a class for ease of well... constructing an object. A \nconstructor\n method is used as a way to quickly create an object of the class by injecting the variable values of the class as parameter of the method. \nGetter\n methods will get the values of the variable\n and \nsetter\n methods will set/change the value of the variables.\n\n\nSince everything is a class in Ruby, you may have noticed how you can use so called \"built-in methods\" with things like arrays and string.\n\n\na_string = \"Hello\"\na_string.reverse # olleH\n\n\n\nObjects\n\n\nAn object is created(instantiated) from a class. To instantiate an object, you type:\n\n\nobject = class.new()\n\n\n\nand the object \nobject\n will have whatever is declared in the class \nclass\n. For example if there is a function \nfoo()\n defined in \nclass\n, we can use it on the \nobject\n by:\n\n\nobject.foo()\n\n\n\nUsing the class \nDog\n above, we can create a dog:\n\n\npet = Dog.new(\"Alex\", \"Husky\", 10) # Create a pet Dog\n\n# Getter\n# puts is used to display on the screen\nputs pet.name # Alex\nputs pet.species # Husky\nputs pet.age # 10\npet.bark # bark, bark, bark\nputs pet.legs # 4\n\n# Setter\n\npet.name = (\"John\")\nputs pet.name # John\n\n\n\nWith this, we can create as many pet dogs as we want without having to write the methods of class \nDog\n over and over again. This is one of the many reasons why OOP is so powerful and preferred by many.\n\n\nnot_cat = Dog.new(\"Milo\", \"German Shepherd\", 5)\na_dog = Dog.new(\"Mayhem\", \"Chihuahua\", 2)\n\nnot_cat.name # Milo\na_dog.species # Chihuahua\n\n\n\nBut wait, there's more\n\n\nNot only being able to reduce the tedious process of writing the code again, OOP can provide security with \nencapsulation\n, robustness with \npolymorphism\n and even more less writing the same code with \ninheritance\n.", 
            "title": "Basics of OOP"
        }, 
        {
            "location": "/challenge-2/OOP/#object-oriented-programming", 
            "text": "Ruby  is a pure Object Oriented Programming Language (OOP). You must remember that everything in Ruby (e.g. an integer, a decimal number or a string) is an object of a particular class.", 
            "title": "Object Oriented Programming"
        }, 
        {
            "location": "/challenge-2/OOP/#classes-and-objects", 
            "text": "If programming is building a house, then a  class  would be the blueprint and the  object  would be the house or an  instance  of a class.", 
            "title": "Classes and Objects"
        }, 
        {
            "location": "/challenge-2/OOP/#class", 
            "text": "A class specifies the variables(what it's object has) and methods(what it's object does). To create a class, you need type:  class class_name\n\n    include anything related to the class here\n\nend  For example a pet dog class would have:  class Dog\n\n      @@number_of_legs = 4\n\n      # Basic initializer\n      def initialize(name, species, age)\n        # Assign the argument to the \"name\" instance variable for the instance\n        @name = name\n        # If no age given, we will fall back to the default in the arguments list.\n        @age = age\n\n        @species = species;\n      end\n\n      # Basic setter method\n      def name=(name)\n        @name = name\n      end\n\n      # Basic getter method\n      def name\n        @name\n      end\n\n      def species\n        @species\n      end\n\n      def age\n        @age\n      end\n\n      def legs\n        @@number_of_legs\n      end\n\n      def bark\n        puts \"bark,bark,bark\"\n      end\nend  As you can see, any variable with two '@' before it  @@number_of_legs  is a class variable. It is shared by all instances(objects) of this class. A dog should always have 4 legs, a name, age, species and the ability to bark which we will display \"bark\" 3 times.\nIn OOP it is good practice to always have constructor, getter and setter methods in a class for ease of well... constructing an object. A  constructor  method is used as a way to quickly create an object of the class by injecting the variable values of the class as parameter of the method.  Getter  methods will get the values of the variable\n and  setter  methods will set/change the value of the variables.  Since everything is a class in Ruby, you may have noticed how you can use so called \"built-in methods\" with things like arrays and string.  a_string = \"Hello\"\na_string.reverse # olleH", 
            "title": "Class"
        }, 
        {
            "location": "/challenge-2/OOP/#objects", 
            "text": "An object is created(instantiated) from a class. To instantiate an object, you type:  object = class.new()  and the object  object  will have whatever is declared in the class  class . For example if there is a function  foo()  defined in  class , we can use it on the  object  by:  object.foo()  Using the class  Dog  above, we can create a dog:  pet = Dog.new(\"Alex\", \"Husky\", 10) # Create a pet Dog\n\n# Getter\n# puts is used to display on the screen\nputs pet.name # Alex\nputs pet.species # Husky\nputs pet.age # 10\npet.bark # bark, bark, bark\nputs pet.legs # 4\n\n# Setter\n\npet.name = (\"John\")\nputs pet.name # John  With this, we can create as many pet dogs as we want without having to write the methods of class  Dog  over and over again. This is one of the many reasons why OOP is so powerful and preferred by many.  not_cat = Dog.new(\"Milo\", \"German Shepherd\", 5)\na_dog = Dog.new(\"Mayhem\", \"Chihuahua\", 2)\n\nnot_cat.name # Milo\na_dog.species # Chihuahua", 
            "title": "Objects"
        }, 
        {
            "location": "/challenge-2/OOP/#but-wait-theres-more", 
            "text": "Not only being able to reduce the tedious process of writing the code again, OOP can provide security with  encapsulation , robustness with  polymorphism  and even more less writing the same code with  inheritance .", 
            "title": "But wait, there's more"
        }, 
        {
            "location": "/challenge-2/encapsulation/", 
            "text": "Inheritance\n\n\nInheritance in Ruby is just the relation between 2 classes where the child class inherits the methods and variables defined in the parent class. Consider this example: You have a class named \nVehicle\n and it has a method called \ndrive()\n. Now, you want to have some way to refer to motorcycles and vans, but although both are vehicles there are some important differences - for example, unlike motorcycles, vans should have a \nlockDoors()\n method.\n\n\nUnderstanding inheritance\n\n\nLet's try to translate the example above from English into Ruby. First of all, we have to define the \nVehicle\n class:\n\n\nclass Vehicle\n  def drive\n    # Drive somewhere\n  end\nend\n\n\n\nNow, we need to create separate class for vans that will ihnerit from the \nVehicle\n class. Note that the symbol \n is used to denote inheritance:\n\n\nclass Van \n Vehicle\n  def lock_doors\n    # Lock doors\n  end\nend\n\n\n\nSince \nVan\n inherits from \nVehicle\n, it has all of the methods that \nVehicle\n class has, namely the \ndrive\n method. This also means that if we change the way \ndrive\n method works in the \nVehicle\n class, changes will affect all child classes immmediately, saving us the trouble of changing each class manually.\n\n\nYou can access the methods inherited from the parent class just like you access any other methods:\n\n\nvan = Van.new\nvan.drive\nvan.lock_doors\n\n\n\nEncapsulation\n\n\nEncapsulation is all about protecting the internal structure of an object from any outside changes. That is to say that whoever is going to use our objects can only access the public methods, while the internal structure and private methods are hidden. By abstracting any data manipulation to specific methods, we make sure that the whole program doesn't depend on a specific line of code but a method as a whole, and as long as this method returns the expected value the program will work regardless of how this value was calculated.\n\n\nHere's a simple example of encapsulation:\n\n\nclass Coat\n  attr_accessor :size\n\n  def initialize(size)\n    @size = size\n  end\n\n  def set_name(size)\n    @size = size\n  end\nend\n\ncoat = Coat.new(10)\n\n# Change the coat size\ncoat.set_name(11)\n\n\n\nNotice how I could easily change the \nsize\n variable stored in the coat object using public methods and without actually accessing the variable itself.\n\n\nPolymorphism\n\n\nPolymorphism is the idea of abstracting different elements behind the same interface. Unfortunately polymorphism is quite hard to implement in Ruby so a concept known as \nduck typing\n is used instead.\n\n\nDuck typing\n\n\nConsider this example: You have 2 shapes, \ncircle\n and \nsquare\n, each with a separate class and a \ndraw\n method. You want to be able to draw whatever shape you get, regardless of whether it is a \ncircle\n or a \nsquare\n. This is how you can approach this problem using duck typing:\n\n\n# First, let's define the class for each shape\nclass Circle\n  def draw\n    # Draw method specific to circles\n  end\nend\n\nclass Square\n  def draw\n    # Draw method specific to squares\n  end\nend\n\n# Now let's make a generic class that will draw any shape\nclass Shape\n  def draw(shape)\n    shape.draw\n  end\nend\n\ncircle_or_square = Circle.new # You can change this to Square.new and the program will still work\n\nshape = Shape.new\nshape.draw(circle_or_square)\n\n\n\nAs you can see, the \ndraw\n method in the \nShape\n class simply expects anything with \ndraw\n method defined, so regardless of the type of object you use, it will call the \ndraw\n method for the particular object mimicking polymorphism behaviour.", 
            "title": "Inheritance, encapsulation and polymorphism"
        }, 
        {
            "location": "/challenge-2/encapsulation/#inheritance", 
            "text": "Inheritance in Ruby is just the relation between 2 classes where the child class inherits the methods and variables defined in the parent class. Consider this example: You have a class named  Vehicle  and it has a method called  drive() . Now, you want to have some way to refer to motorcycles and vans, but although both are vehicles there are some important differences - for example, unlike motorcycles, vans should have a  lockDoors()  method.", 
            "title": "Inheritance"
        }, 
        {
            "location": "/challenge-2/encapsulation/#understanding-inheritance", 
            "text": "Let's try to translate the example above from English into Ruby. First of all, we have to define the  Vehicle  class:  class Vehicle\n  def drive\n    # Drive somewhere\n  end\nend  Now, we need to create separate class for vans that will ihnerit from the  Vehicle  class. Note that the symbol   is used to denote inheritance:  class Van   Vehicle\n  def lock_doors\n    # Lock doors\n  end\nend  Since  Van  inherits from  Vehicle , it has all of the methods that  Vehicle  class has, namely the  drive  method. This also means that if we change the way  drive  method works in the  Vehicle  class, changes will affect all child classes immmediately, saving us the trouble of changing each class manually.  You can access the methods inherited from the parent class just like you access any other methods:  van = Van.new\nvan.drive\nvan.lock_doors", 
            "title": "Understanding inheritance"
        }, 
        {
            "location": "/challenge-2/encapsulation/#encapsulation", 
            "text": "Encapsulation is all about protecting the internal structure of an object from any outside changes. That is to say that whoever is going to use our objects can only access the public methods, while the internal structure and private methods are hidden. By abstracting any data manipulation to specific methods, we make sure that the whole program doesn't depend on a specific line of code but a method as a whole, and as long as this method returns the expected value the program will work regardless of how this value was calculated.  Here's a simple example of encapsulation:  class Coat\n  attr_accessor :size\n\n  def initialize(size)\n    @size = size\n  end\n\n  def set_name(size)\n    @size = size\n  end\nend\n\ncoat = Coat.new(10)\n\n# Change the coat size\ncoat.set_name(11)  Notice how I could easily change the  size  variable stored in the coat object using public methods and without actually accessing the variable itself.", 
            "title": "Encapsulation"
        }, 
        {
            "location": "/challenge-2/encapsulation/#polymorphism", 
            "text": "Polymorphism is the idea of abstracting different elements behind the same interface. Unfortunately polymorphism is quite hard to implement in Ruby so a concept known as  duck typing  is used instead.", 
            "title": "Polymorphism"
        }, 
        {
            "location": "/challenge-2/encapsulation/#duck-typing", 
            "text": "Consider this example: You have 2 shapes,  circle  and  square , each with a separate class and a  draw  method. You want to be able to draw whatever shape you get, regardless of whether it is a  circle  or a  square . This is how you can approach this problem using duck typing:  # First, let's define the class for each shape\nclass Circle\n  def draw\n    # Draw method specific to circles\n  end\nend\n\nclass Square\n  def draw\n    # Draw method specific to squares\n  end\nend\n\n# Now let's make a generic class that will draw any shape\nclass Shape\n  def draw(shape)\n    shape.draw\n  end\nend\n\ncircle_or_square = Circle.new # You can change this to Square.new and the program will still work\n\nshape = Shape.new\nshape.draw(circle_or_square)  As you can see, the  draw  method in the  Shape  class simply expects anything with  draw  method defined, so regardless of the type of object you use, it will call the  draw  method for the particular object mimicking polymorphism behaviour.", 
            "title": "Duck typing"
        }
    ]
}